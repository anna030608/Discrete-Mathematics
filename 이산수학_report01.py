# -*- coding: utf-8 -*-
"""이산수학_report01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-MUASUmKsxRptKohNF9iRIOhgfpy9DTR

## 행렬 입력 기능
- 한 행 씩 입력 받아서 저장.
- 2차원 배열로 저장

## 행렬식 계산 - 함수로 구현해야 함.
- 행렬식 계산 후 0인지 판별
- 행렬식 = 0 -> 역행렬 존재 X -> 오류 메시지 출력
- 행렬식 != 0 -> 역행렬 계산

## 가우스-조던 소거법 - 함수 구현
- 가우스 조던 소거법을 사용하여 동일한 행렬의 역행렬 계산 함수 구현
- 역행렬 존재 X -> 예외 처리 포함

## 결과 출력 및 비교 기능
- 각 방법으로 계산한 역행렬 각각 출력
- 두 결과가 동일한지 비교 결과 메시지 출력

# 추가 기능 구현!!
- 역행렬 검증 기능 구현
- 구한 역행렬이 정말 맞는지 확인하기 위해 A*A-1 = I 인지 곱셈으로 검증해주는 기능
"""



# 전치 행렬 구하는 함수
def transposeMatrix(m):
  return [[m[j][i] for j in range(len(m))] for i in range(len(m[0]))]

# 소행렬 구하는 함수
def getMatrixMinor(m, i, j):
  return [row[:j]+row[j+1:] for row in (m[:i]+m[i+1:])]

# 행렬식 계산 함수
def getMatrixDeterminant(m):
  if len(m) == 1:
    return m[0][0]
  if len(m) == 2:
    return m[0][0]*m[1][1] - m[0][1]*m[1][0]

  determinant = 0
  for c in range(len(m)):
    determinant += ((-1)**c)*m[0][c]*getMatrixDeterminant(getMatrixMinor(m, 0, c))
  return determinant

# 역행렬 존재 여부 확인 함수
def has_inverse(m):
  determinant = getMatrixDeterminant(m)

  if abs(determinant) < 1e-10:
    print("오류 : 행렬식이 0입니다.")
    print("역행렬 계산 불가능")
    return False
  return True

# 행렬식을 이용한 역행렬 계산 함수
def getMatrixInverse(m):
    determinant = getMatrixDeterminant(m)

    if len(m) == 1:
      return [[1.0 / m[0][0]]]

    if len(m) == 2:
      return [[m[1][1] / determinant, -1 * m[0][1] / determinant],
              [-1 * m[1][0] / determinant, m[0][0] / determinant]]

    cofactors = []
    for r in range(len(m)):
        cofactorRow = []
        for c in range(len(m)):
            minor = getMatrixMinor(m, r, c)
            cofactorRow.append(((-1) ** (r + c)) * getMatrixDeterminant(minor))
        cofactors.append(cofactorRow)

    adjugate = transposeMatrix(cofactors)
    for r in range(len(adjugate)):
        for c in range(len(adjugate)):
            adjugate[r][c] = adjugate[r][c] / determinant

    return adjugate

def GaussJordanElimination(m):
  n = len(m)
  # 원본 보존 + float 연산
  A = [list(map(float, row)) for row in m]
  I = [[1.0 if i == j else 0.0 for j in range(n)] for i in range(n)]

  for col in range(n):
    # 1) 피벗 선택(부분 피벗팅)
    pivot_row = max(range(col, n), key=lambda r: abs(A[r][col]))
    if abs(A[pivot_row][col]) < 1e-12:
      raise ValueError("가우스-조던: 특이행렬(피벗 0) → 역행렬 없음")

    # 2) 행 교환
    if pivot_row != col:
      A[col], A[pivot_row] = A[pivot_row], A[col]
      I[col], I[pivot_row] = I[pivot_row], I[col]

    # 3) 피벗을 1로(행 정규화)
    pivot = A[col][col]
    for j in range(n):
      A[col][j] /= pivot
      I[col][j] /= pivot

    # 4) 다른 행들의 해당 열을 0으로
    for r in range(n):
      if r == col:
        continue
      factor = A[r][col]
      if factor != 0.0:
        for j in range(n):
          A[r][j] -= factor * A[col][j]
          I[r][j] -= factor * I[col][j]

  return I  # A는 I가 되고, I는 A^{-1}

def matrices_almost_equal(A, B, tol=1e-10):
  if len(A) != len(B) or any(len(A[i]) != len(B[i]) for i in range(len(A))):
    return False
  n = len(A)
  for i in range(n):
    for j in range(n):
      if abs(A[i][j] - B[i][j]) > tol:
        return False
  return True

import math

def verify_inverse(A, Ainv, tol=1e-10, print_products=False):
    """
    추가 기능: 역행렬 검증
    - 목적: 구해진 Ainv가 실제로 A의 역행렬인지 확인
    - 방법: P_left = A @ Ainv, P_right = Ainv @ A 를 계산하여 I(항등행렬)과 비교
            잔차 R = P - I 에 대해 최대절대오차, Frobenius 노름, 상대 잔차 출력
    - tol: 부동소수 오차 허용치
    - print_products=True로 두면 P_left, P_right를 함께 출력(캡처용)
    """

    def matmul(X, Y):
        n = len(X); m = len(Y[0]); k = len(Y)
        return [[sum(X[i][t] * Y[t][j] for t in range(k)) for j in range(m)] for i in range(n)]

    def identity(n):
        return [[1.0 if i == j else 0.0 for j in range(n)] for i in range(n)]

    def subtract(X, Y):
        n = len(X); m = len(X[0])
        return [[X[i][j] - Y[i][j] for j in range(m)] for i in range(n)]

    def max_abs_entry(M):
        return max(abs(x) for row in M for x in row) if M else 0.0

    def frobenius_norm(M):
        return math.sqrt(sum(x*x for row in M for x in row))

    def rel_residual(R, A, Ainv):
        # ||R||_F / (||A||_F * ||A^{-1}||_F)
        def nF(X): return frobenius_norm(X)
        denom = nF(A) * nF(Ainv)
        return (frobenius_norm(R) / denom) if denom > 0 else 0.0

    n = len(A)
    I = identity(n)

    # 좌측 검증: A * Ainv ≈ I
    P_left = matmul(A, Ainv)
    R_left = subtract(P_left, I)
    max_err_left = max_abs_entry(R_left)
    rel_left = rel_residual(R_left, A, Ainv)

    print("\n[추가기능] 역행렬 검증 : A × A^{-1}")
    if print_products:
        for row in P_left: print(row)
    print(f"최대 절대오차: {max_err_left:.3e}")
    print(f"상대 잔차   : {rel_left:.3e}")
    print("판정         :", "허용오차 내 일치" if max_err_left <= tol else "불일치")

def main():
  try:
    n = int(input("차수를 입력하시오: "))

    if n <= 0:
      print("차수는 양의 정수여야 합니다.")
      return

    print("각 행단위로 입력하시오.")
    matrix = []
    for i in range(n):
      while True:
        try:
          row = list(map(int, input().split()))
          if len(row) != n:
            print(f"입력 오류 : 행의 길이는 {n}이어야 합니다.")
            continue
          matrix.append(row)
          break
        except ValueError:
          print("입력 오류 : 숫자를 입력하시오.")
    if has_inverse(matrix):
      print("----------------------------------------------------")
      print("행렬식을 이용한 역행렬은 다음과 같습니다.")
      inverse1 = getMatrixInverse(matrix)
      for row in inverse1:
        print(row)

      verify_inverse([[float(x) for x in row] for row in matrix],
               [[float(x) for x in row] for row in inverse1],
               tol=1e-10, print_products=False)

      print("----------------------------------------------------")
      print("가우스-조던 소거법을 이용한 역행렬은 다음과 같습니다.")
      inverse2 = GaussJordanElimination(matrix)
      for row in inverse2:
        print(row)

      verify_inverse([[float(x) for x in row] for row in matrix],
               [[float(x) for x in row] for row in inverse2],
               tol=1e-9, print_products=False)

      if matrices_almost_equal(inverse1, inverse2, tol=1e-9):
        print("----------------------------------------------------")
        print("두 역행렬이 동일합니다.(허용오차 내)")
      else:
        print("----------------------------------------------------")
        print("두 역행렬이 동일하지 않습니다.")


    else:
      print("----------------------------------------------------")
      print("역행렬 존재 X")


  except ValueError:
    print("숫자를 입력하시오.")
  except Exception as e:
    print(e)
  print()

## Testcase 1
if __name__ == "__main__":
  main()

## Testcase 2
if __name__ == "__main__":
  main()

## Testcase 3
if __name__ == "__main__":
  main()

